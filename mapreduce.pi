import "Std/List"
import "Std/String"
import "Std/Int"
import "Std/Array"

{- append helper function. combines two lists -}
def append [#X xs:(List X) ys:(List X) q:/(List X)] =
  if (null xs) then
    q!ys
  else
    ( new k:^(List X)
      ( append![#X (cdr xs) ys (rchan k)]
      | k?zs:(List X) = q!(cons (car xs) zs) ))

{- printer list helper function. prints all values of a list of type integer -}
def printList xs:(List Int) =
  if (null xs) then
    print!"\n"
  else
    ( printi!(car xs)
    | print!" "
    | printList!(cdr xs) )

{- reverse list helper function. reverses a list -}
def revAcc [#X xs:(List X) acc:(List X) q:/(List X)] =
  if (null xs) then
    q!acc
  else
    revAcc![#X (cdr xs) (cons (car xs) acc) q]

{- reverse list helper -}
def rev [#X xs:(List X) q:/(List X)] =
  revAcc![#X xs nil q]

def lengthAcc [#X xs:(List X) n:Int q:/Int] =
  if (null xs) then
    q!n
  else
    ( new sum:^Int
      ( +![n 1 (rchan sum)]            
      | sum?np1:Int = lengthAcc![#X (cdr xs) np1 q] ))

def length [#X xs:(List X) q:/Int] =
  lengthAcc![#X xs 0 q]
  
{- inc: x â†¦ x + 1, returning via q -}
def increment [x:Int q:/Int] =
  ( new s:^Int
    ( +![x 1 (rchan s)]
    | s?r:Int = q!r ))

{- mapList: apply f to each element of xs, collect results in order, send on q -}
def mapList [#A #B xs:(List A) f:/[A /B] q:/(List B)] =
  if (null xs) then
    q!nil
  else
    ( new b:^B            {- result of f (car xs) -}
      new tl:^(List B)    {- mapped tail -}
      ( f![(car xs) (rchan b)]
      | b?y:B =
          ( mapList![#A #B (cdr xs) f (rchan tl)]
          | tl?ys:(List B) = q!(cons y ys) ) ) )

val xs = (cons 1 (cons 2 (cons 3 nil)))
val ys = (cons 4 (cons 5 nil))

new a:^(List Int)
run (
  append![#Int xs ys (rchan a)]
| a?zs:(List Int) =
    ( 
      ( print!"orig: " | printList!zs )
    | ( new m:^(List Int)
        ( mapList![#Int #Int zs increment (rchan m)]
        | m?ms:(List Int) = ( print!"map(+1): " | printList!ms )
        )
      )
    )
)