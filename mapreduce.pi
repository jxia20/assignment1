{-=========================================================
  RPI CSCI MapReduce in Pict — Organized & Commented
  ---------------------------------------------------
  Sections:
    0) Imports & Inputs
    1) Core tiny helpers (Char/String/Int)
    2) Generic List helpers (append/rev/length/map/flatMap)
    3) Sorting by Int keys (merge sort & split)
    4) Sorting by String keys (merge sort & split)
    5) Pair helpers (Int-key and String-key)
    6) Group-by (Int-key, String-key)
    7) FlatMap over groups (Int-key, String-key)
    8) MapReduce (Int-key, String-key)
    9) Printing helpers (ints, pairs, grouped forms)
   10) Word search pipeline (tokenize, lowercase, substring)
   11) Stats pipeline (chars, words, etc.)
   12) Main run
=========================================================-}

{-============================
  0) Imports & Inputs
============================-}
import "Std/List"
import "Std/String"
import "Std/Int"
import "Std/Array"
import "Std/Char"
import "Std/Float"

val needle = "is"   {- search needle -}

val inputS =
  (cons [1  "WHEN I consider how my light is spent"]
  (cons [2  "  E're half my days, in this dark world and wide,"]
  (cons [3  "  And that one Talent which is death to hide,"]
  (cons [4  "  Lodg'd with me useless, though my Soul more bent"]
  (cons [5  "To serve therewith my Maker, and present"]
  (cons [6  "  My true account, least he returning chide,"]
  (cons [7  "  Doth God exact day-labour, light deny'd,"]
  (cons [8  "  I fondly ask; But patience to prevent"]
  (cons [9  "That murmur, soon replies, God doth not need"]
  (cons [10 "  Either man's work or his own gifts, who best"]
  (cons [11 "  Bear his milde yoak, they serve him best, his State"]
  (cons [12 "Is Kingly. Thousands at his bidding speed"]
  (cons [13 "  And post o're Land and Ocean without rest:"]
  (cons [14 "  They also serve who only stand and waite."]
        nil))))))))))))))

{-============================
  1) Core tiny helpers
============================-}

{- Char -> String -}
def charToString [c:Char q:/String] =
  string.fromList![(cons c nil) (rchan q)]

{- clamp negatives to 0 (for safe substring windows) -}
def clampNonNeg [x:Int q:/Int] =
  ( new le0:^Bool
    ( <=![x 0 (rchan le0)]
    | le0?yes:Bool = if yes then q!0 else q!x ) )

{- min of two ints via <= guard -}
def min2 [a:Int b:Int q:/Int] =
  ( new le:^Bool
    ( <=![a b (rchan le)]
    | le?ok:Bool = if ok then q!a else q!b ) )

{- safe substring: sub s start len, clamps out-of-range to "" -}
def sub [s:String start:Int len:Int q:/String] =
  ( new L:^Int
    ( string.size![s (rchan L)]
    | L?n:Int =
        ( new s0:^Int new l0:^Int
          ( clampNonNeg![start (rchan s0)]
          | clampNonNeg![len   (rchan l0)]
          | s0?st:Int = l0?ln:Int =
              ( new tooFar:^Bool
                ( <=![n st (rchan tooFar)]
                | tooFar?out:Bool =
                    if out then q!"" else
                      ( new maxLen:^Int
                        ( -![n st (rchan maxLen)]
                        | maxLen?ml:Int =
                            ( new useLen:^Int
                              ( min2![ln ml (rchan useLen)]
                              | useLen?k:Int =
                                  string.sub![s st k (rchan q)] ) ) ) ) ) ) ) ) ) )

def strlen [s:String q:/Int] = string.size![s (rchan q)]

{-============================
  2) Generic List helpers
============================-}

{- append for any List X -}
def append [#X xs:(List X) ys:(List X) q:/(List X)] =
  if (null xs) then q!ys
  else ( new k:^(List X)
         ( append![#X (cdr xs) ys (rchan k)]
         | k?zs:(List X) = q!(cons (car xs) zs) ))

{- reverse -}
def revAcc [#X xs:(List X) acc:(List X) q:/(List X)] =
  if (null xs) then q!acc
  else revAcc![#X (cdr xs) (cons (car xs) acc) q]

def rev [#X xs:(List X) q:/(List X)] = revAcc![#X xs nil q]

{- length -}
def lengthAcc [#X xs:(List X) n:Int q:/Int] =
  if (null xs) then q!n
  else ( new sum:^Int
         ( +![n 1 (rchan sum)]
         | sum?np1:Int = lengthAcc![#X (cdr xs) np1 q] ))

def length [#X xs:(List X) q:/Int] = lengthAcc![#X xs 0 q]

{- map and flatMap over lists -}
def mapList [#A #B xs:(List A) f:/[A /B] q:/(List B)] =
  if (null xs) then q!nil
  else ( new b:^B new tl:^(List B)
         ( f![(car xs) (rchan b)]
         | b?y:B =
             ( mapList![#A #B (cdr xs) f (rchan tl)]
             | tl?ys:(List B) = q!(cons y ys) ) ) )

def flatMap [#A #B xs:(List A) f:/[A /(List B)] q:/(List B)] =
  if (null xs) then q!nil
  else ( new h:^(List B) new t:^(List B) new a:^(List B)
         ( f![(car xs) (rchan h)]
         | flatMap![#A #B (cdr xs) f (rchan t)]
         | h?hs:(List B) = t?ts:(List B) = append![#B hs ts (rchan a)]
         | a?res:(List B) = q!res ) )

{-============================
  3) Sorting by Int keys
============================-}

{- append for pairs [Int V] -}
def appendPairs [#V xs:(List [Int V]) ys:(List [Int V]) q:/(List [Int V])] =
  if (null xs) then q!ys
  else ( new k:^(List [Int V])
         ( appendPairs![#V (cdr xs) ys (rchan k)]
         | k?zs:(List [Int V]) = q!(cons (car xs) zs) ))

{- merge two sorted lists by Int key -}
def mergePairs [#V xs:(List [Int V]) ys:(List [Int V]) cmp:/[Int Int /Bool] q:/(List [Int V])] =
  if (null xs) then q!ys
  else if (null ys) then q!xs
  else
    ( val [kx vx] = (car xs)
      val [ky vy] = (car ys)
      new le:^Bool
      ( cmp![kx ky (rchan le)]
      | le?isLE:Bool =
          if isLE then
            ( new rest:^(List [Int V])
              ( mergePairs![#V (cdr xs) ys cmp (rchan rest)]
              | rest?rs:(List [Int V]) = q!(cons [kx vx] rs) ) )
          else
            ( new rest:^(List [Int V])
              ( mergePairs![#V xs (cdr ys) cmp (rchan rest)]
              | rest?rs:(List [Int V]) = q!(cons [ky vy] rs) ) ) ) )

{- split alternating into two lists -}
def splitPairs_go [#V ys:(List [Int V]) a:(List [Int V]) b:(List [Int V]) q:/[(List [Int V]) (List [Int V])]] =
  if (null ys) then q![a b]
  else if (null (cdr ys)) then q![(cons (car ys) a) b]
  else splitPairs_go![#V (cdr (cdr ys)) (cons (car ys) a) (cons (car (cdr ys)) b) q]

def splitPairs [#V xs:(List [Int V]) q:/[(List [Int V]) (List [Int V])]] =
  splitPairs_go![#V xs nil nil q]

{- msort by Int key -}
def msortPairs [#V xs:(List [Int V]) cmp:/[Int Int /Bool] q:/(List [Int V])] =
  if (null xs) then q!nil
  else if (null (cdr xs)) then q!xs
  else
    ( new halves:^[(List [Int V]) (List [Int V])]
      ( splitPairs![#V xs (rchan halves)]
      | halves?lr:[(List [Int V]) (List [Int V])] =
          ( val left  = (fst lr)
            val right = (snd lr)
            new sl:^(List [Int V]) new sr:^(List [Int V]) new m:^(List [Int V])
            ( msortPairs![#V left  cmp (rchan sl)]
            | msortPairs![#V right cmp (rchan sr)]
            | sl?l:(List [Int V]) = sr?r:(List [Int V]) =
                mergePairs![#V l r cmp (rchan m)]
            | m?res:(List [Int V]) = q!res ) ) ))

{- basic int compares -}
def increment [x:Int q:/Int] = ( new s:^Int ( +![x 1 (rchan s)] | s?r:Int = q!r ) )
def compareInt [x:Int y:Int q:/Bool] = ( new b:^Bool ( <=![x y (rchan b)] | b?res = q!res ) )
def eqInt [x:Int y:Int q:/Bool] = ( new b:^Bool ( ==![x y (rchan b)] | b?res = q!res ) )

{-============================
  4) Sorting by String keys
============================-}

def appendPairsS [#T xs:(List [String T]) ys:(List [String T]) q:/(List [String T])] =
  if (null xs) then q!ys
  else ( new k:^(List [String T])
         ( appendPairsS![#T (cdr xs) ys (rchan k)]
         | k?zs:(List [String T]) = q!(cons (car xs) zs) ))

def mergePairsS [#V xs:(List [String V]) ys:(List [String V]) cmp:/[String String /Bool] q:/(List [String V])] =
  if (null xs) then q!ys
  else if (null ys) then q!xs
  else
    ( val px = (car xs)  val py = (car ys)
      val kx = (fst px)  val ky = (fst py)
      val vx = (snd px)  val vy = (snd py)
      new le:^Bool
      ( cmp![kx ky (rchan le)]
      | le?isLE:Bool =
          if isLE then
            ( new rest:^(List [String V])
              ( mergePairsS![#V (cdr xs) ys cmp (rchan rest)]
              | rest?rs:(List [String V]) = q!(cons [kx vx] rs) ) )
          else
            ( new rest:^(List [String V])
              ( mergePairsS![#V xs (cdr ys) cmp (rchan rest)]
              | rest?rs:(List [String V]) = q!(cons [ky vy] rs) ) ) ) )

def splitPairsS_go [#V ys:(List [String V]) a:(List [String V]) b:(List [String V]) q:/[(List [String V]) (List [String V])]] =
  if (null ys) then q![a b]
  else if (null (cdr ys)) then q![(cons (car ys) a) b]
  else splitPairsS_go![#V (cdr (cdr ys)) (cons (car ys) a) (cons (car (cdr ys)) b) q]

def splitPairsS [#V xs:(List [String V]) q:/[(List [String V]) (List [String V])]] =
  splitPairsS_go![#V xs nil nil q]

def msortPairsS [#V xs:(List [String V]) cmp:/[String String /Bool] q:/(List [String V])] =
  if (null xs) then q!nil
  else if (null (cdr xs)) then q!xs
  else
    ( new halves:^[(List [String V]) (List [String V])]
      ( splitPairsS![#V xs (rchan halves)]
      | halves?lr:[(List [String V]) (List [String V])] =
          ( val left  = (fst lr)
            val right = (snd lr)
            new sl:^(List [String V]) new sr:^(List [String V]) new m:^(List [String V])
            ( msortPairsS![#V left  cmp (rchan sl)]
            | msortPairsS![#V right cmp (rchan sr)]
            | sl?l:(List [String V]) = sr?r:(List [String V]) =
                mergePairsS![#V l r cmp (rchan m)]
            | m?res:(List [String V]) = q!res ) ) ))

def leStr [a:String b:String q:/Bool] = <=$![a b (rchan q)]
def eqStr [x:String y:String q:/Bool] = ( new b:^Bool ( ==$![x y (rchan b)] | b?res = q!res ) )

{-============================
  5) Pair helpers (Int-key & String-key)
============================-}

{- “dup” and tiny reducers -}
def dup [x:Int q:/(List Int)] = q!(cons x (cons x nil))

def sumList [xs:(List Int) r:/Int] =
  if (null xs) then r!0
  else ( new t:^Int
         ( sumList![(cdr xs) (rchan t)]
         | t?s:Int = +![(car xs) s (rchan r)] ))

def reduceSum [g:[Int (List Int)] q:/(List [Int Int])] =
  ( val [k vs] = g
    new s:^Int
    ( sumList![vs (rchan s)]
    | s?total:Int = q!(cons [k total] nil) ))

{-============================
  6) Group-by (Int-key, String-key)
============================-}

{- collect run of same Int key (input is sorted) -}
def collectSameKey [#V ys:(List [Int V]) key:Int acc:(List V) qa:/(List V) qb:/(List [Int V])] =
  if (null ys) then ( qa!acc | qb!nil )
  else
    ( val p = (car ys)
      val k = (fst p)
      val v = (snd p)
      new eq:^Bool
      ( eqInt![key k (rchan eq)]
      | eq?same:Bool =
          if same then collectSameKey![#V (cdr ys) key (cons v acc) qa qb]
          else ( qa!acc | qb!ys ) ) )

def groupByKey [#V xs:(List [Int V]) q:/(List [Int (List V)])] =
  if (null xs) then q!nil
  else
    ( val p0 = (car xs)  val k0 = (fst p0)  val v0 = (snd p0)
      new vals:^(List V) new rest:^(List [Int V])
      ( collectSameKey![#V (cdr xs) k0 (cons v0 nil) (rchan vals) (rchan rest)]
      | vals?revVals:(List V) =
          ( new fwd:^(List V)
            ( rev![#V revVals (rchan fwd)]
            | fwd?vs:(List V) =
                rest?rem:(List [Int V]) =
                  ( new tail:^(List [Int (List V)])
                    ( groupByKey![#V rem (rchan tail)]
                    | tail?gs:(List [Int (List V)]) = q!(cons [k0 vs] gs) ) ) ) ) ) )

{- String version -}
def collectSameKeyS [#V ys:(List [String V]) key:String acc:(List V) qa:/(List V) qb:/(List [String V])] =
  if (null ys) then ( qa!acc | qb!nil )
  else
    ( val p = (car ys)  val k = (fst p)  val v = (snd p)
      new eq:^Bool
      ( eqStr![key k (rchan eq)]
      | eq?same:Bool =
          if same then collectSameKeyS![#V (cdr ys) key (cons v acc) qa qb]
          else ( qa!acc | qb!ys ) ) )

def groupByKeyS [#V xs:(List [String V]) q:/(List [String (List V)])] =
  if (null xs) then q!nil
  else
    ( val p0 = (car xs)  val k0 = (fst p0)  val v0 = (snd p0)
      new vals:^(List V) new rest:^(List [String V])
      ( collectSameKeyS![#V (cdr xs) k0 (cons v0 nil) (rchan vals) (rchan rest)]
      | vals?revVals:(List V) =
          ( new fwd:^(List V)
            ( rev![#V revVals (rchan fwd)]
            | fwd?vs:(List V) =
                rest?rem:(List [String V]) =
                  ( new tail:^(List [String (List V)] )
                    ( groupByKeyS![#V rem (rchan tail)]
                    | tail?gs:(List [String (List V)]) = q!(cons [k0 vs] gs) ) ) ) ) ) )

{-============================
  7) FlatMap over groups (Int-key, String-key)
============================-}

def flatMapPairs [#V xs:(List [Int V]) f:/[[Int V] /(List [Int V])] q:/(List [Int V])] =
  if (null xs) then q!nil
  else ( new h:^(List [Int V]) new t:^(List [Int V]) new a:^(List [Int V])
         ( f![(car xs) (rchan h)]
         | flatMapPairs![#V (cdr xs) f (rchan t)]
         | h?hs:(List [Int V]) = t?ts:(List [Int V]) =
             appendPairs![#V hs ts (rchan a)]
         | a?res:(List [Int V]) = q!res ) )

def flatMapGroups [#V #W xs:(List [Int (List V)]) f:/[[Int (List V)] /(List [Int W])] q:/(List [Int W])] =
  if (null xs) then q!nil
  else ( new h:^(List [Int W]) new t:^(List [Int W]) new a:^(List [Int W])
         ( f![(car xs) (rchan h)]
         | flatMapGroups![#V #W (cdr xs) f (rchan t)]
         | h?hs:(List [Int W]) = t?ts:(List [Int W]) =
             appendPairs![#W hs ts (rchan a)]
         | a?res:(List [Int W]) = q!res ) )

def flatMapPairsS [#V xs:(List [String V]) f:/[[String V] /(List [String V])] q:/(List [String V])] =
  if (null xs) then q!nil
  else ( new h:^(List [String V]) new t:^(List [String V]) new a:^(List [String V])
         ( f![(car xs) (rchan h)]
         | flatMapPairsS![#V (cdr xs) f (rchan t)]
         | h?hs:(List [String V]) = t?ts:(List [String V]) =
             appendPairsS![#V hs ts (rchan a)]
         | a?res:(List [String V]) = q!res ) )

def flatMapGroupsS [#V #W xs:(List [String (List V)]) f:/[[String (List V)] /(List [String W])] q:/(List [String W])] =
  if (null xs) then q!nil
  else ( new h:^(List [String W]) new t:^(List [String W]) new a:^(List [String W])
         ( f![(car xs) (rchan h)]
         | flatMapGroupsS![#V #W (cdr xs) f (rchan t)]
         | h?hs:(List [String W]) = t?ts:(List [String W]) =
             appendPairsS![#W hs ts (rchan a)]
         | a?res:(List [String W]) = q!res ) )

def flatMapIS [xs:(List [Int String])
               f:/[[Int String] /(List [String Int])]
               q:/(List [String Int])] =
  if (null xs) then
    q!nil
  else
    ( new h:^(List [String Int]) new t:^(List [String Int]) new a:^(List [String Int])
      ( f![(car xs) (rchan h)]
      | flatMapIS![(cdr xs) f (rchan t)]
      | h?hs:(List [String Int]) = t?ts:(List [String Int]) =
          appendPairsS![#Int hs ts (rchan a)]
      | a?res:(List [String Int]) = q!res ) )

def flatMapFromIS [#V xs:(List [Int String])
                   f:/[[Int String] /(List [String V])]
                   q:/(List [String V])] =
  if (null xs) then
    q!nil
  else
    ( new h:^(List [String V]) new t:^(List [String V]) new a:^(List [String V])
      ( f![(car xs) (rchan h)]
      | flatMapFromIS![#V (cdr xs) f (rchan t)]
      | h?hs:(List [String V]) = t?ts:(List [String V]) =
          appendPairsS![#V hs ts (rchan a)]
      | a?res:(List [String V]) = q!res ) )
      
{-============================
  8) MapReduce (Int-key, String-key)
============================-}

{- comparator wrappers -}
def compareWordLen [a:String b:String q:/Bool] =
  ( new la:^Int new lb:^Int
    ( strlen![a (rchan la)]
    | strlen![b (rchan lb)]
    | la?na:Int = lb?nb:Int =
        ( new sameLen:^Bool
          ( eqInt![na nb (rchan sameLen)]
          | sameLen?eqL:Bool =
              if eqL then ( new lex:^Bool ( <=$![a b (rchan lex)] | lex?ok:Bool = q!ok ) )
              else ( new le:^Bool ( compareInt![na nb (rchan le)] | le?ok2:Bool = q!ok2 ) ) ) ) ) )

{- Int-key generic -}
def mapReduce [#V #W
              mapF:/[[Int V] /(List [Int V])]
              cmp:/[Int Int /Bool]
              reduceF:/[[Int (List V)] /(List [Int W])]
              input:(List [Int V]) q:/(List [Int W])] =
  ( new mapped:^(List [Int V])
    new sorted:^(List [Int V])
    new grouped:^(List [Int (List V)])
    new reduced:^(List [Int W])
    ( flatMapPairs![#V input mapF (rchan mapped)]
    | mapped?m:(List [Int V]) = msortPairs![#V m cmp (rchan sorted)]
    | sorted?s:(List [Int V]) = groupByKey![#V s (rchan grouped)]
    | grouped?g:(List [Int (List V)]) = flatMapGroups![#V #W g reduceF (rchan reduced)]
    | reduced?out:(List [Int W]) = q!out ) )

{- String-key generic -}
def mapReduceS [#V #W
               mapF:/[[String V] /(List [String V])]
               cmp:/[String String /Bool]
               reduceF:/[[String (List V)] /(List [String W])]
               input:(List [String V]) q:/(List [String W])] =
  ( new mapped:^(List [String V])
    new sorted:^(List [String V])
    new grouped:^(List [String (List V)])
    new reduced:^(List [String W])
    ( flatMapPairsS![#V input mapF (rchan mapped)]
    | mapped?m:(List [String V]) = msortPairsS![#V m cmp (rchan sorted)]
    | sorted?s:(List [String V]) = groupByKeyS![#V s (rchan grouped)]
    | grouped?g:(List [String (List V)]) = flatMapGroupsS![#V #W g reduceF (rchan reduced)]
    | reduced?out:(List [String W]) = q!out ) )

{-============================
  9) Printing helpers
============================-}

{- pairs k:v -}
def printPairKV p:[Int Int] =
  ( val [k v] = p
    ( printi!k | ( print!":" | ( printi!v | print!"" ) ) ) )

def printPairsKV xs:(List [Int Int]) =
  if (null xs) then print!"\n"
  else ( printPairKV!(car xs) | printPairsKV!(cdr xs) )

{- simple list -}
def printList xs:(List Int) =
  if (null xs) then print!"\n"
  else ( printi!(car xs) | print!" " | printList!(cdr xs) )

{- sync printing to avoid interleaving -}
def printListSync [xs:(List Int) q:/[]] =
  if (null xs) then q![]
  else ( printi!(car xs) | print!" " | printListSync![(cdr xs) q] )

def printGroup g:[Int (List Int)] =
  ( val [k vs] = g
    ( printi!k | printList!vs ) )

def printGroupSync [g:[Int (List Int)] q:/[]] =
  ( val [k vs] = g
    ( printi!k | print!":" |
      ( new done:^[]
        ( printListSync![vs (rchan done)]
        | done?[] = ( print!"\n" | q![] ) ) ) ) )

def printGroupsSync [gs:(List [Int (List Int)]) q:/[]] =
  if (null gs) then q![]
  else ( new k:^[] ( printGroupSync![(car gs) (rchan k)]
       | k?[] = printGroupsSync![(cdr gs) q] ) )

{- join ints with spaces into String -}
def joinIntsWithSpaces [xs:(List Int) q:/String] =
  (def go [ys:(List Int) sep:String acc:String q:/String] =
     if (null ys) then q!acc
     else
       ( new t1:^String
         ( +$![acc sep (rchan t1)]
         | t1?a:String =
             ( new h:^String
               ( +$![a (int.toString (car ys)) (rchan h)]
               | h?na:String = go![(cdr ys) " " na (rchan q)] ) ) ) )
   go![xs "" "" (rchan q)] )

def printGroupS [g:[String (List Int)] q:/[]] =
  ( new nums:^String
    ( joinIntsWithSpaces![(snd g) (rchan nums)]
    | nums?line:String =
        ( print!(fst g) | print!": " | print!line | print!"\n" | q![] ) ) )

def printGroupSWithCount [g:[String (List Int)] q:/[]] =
  ( val w  = (fst g)
    val ls = (snd g)
    new n:^Int new line:^String
    ( length![#Int ls (rchan n)]
    | joinIntsWithSpaces![ls (rchan line)]
    | n?cnt:Int = line?txt:String =
        ( print!w | print!" (" | printi!cnt | print!") : " | print!txt | print!"\n" | q![] ) ) )

def printGroupSOneShot [g:[String (List Int)] q:/[]] =
  ( val w  = (fst g)
    val ls = (snd g)
    new cnt:^Int new nums:^String
    ( length![#Int ls (rchan cnt)]
    | joinIntsWithSpaces![ls (rchan nums)]
    | cnt?n:Int = nums?ns:String =
        ( new s1:^String
          ( +$![w " (" (rchan s1)]
          | s1?a1:String =
              ( new s2:^String
                ( +$![a1 (int.toString n) (rchan s2)]
                | s2?a2:String =
                    ( new s3:^String
                      ( +$![a2 ") : " (rchan s3)]
                      | s3?a3:String =
                          ( new line:^String
                            ( +$![a3 ns (rchan line)]
                            | line?L:String = ( print!L | print!"\n" | q![] ) ) ) ) ) ) ) ) ) ) )

def printGroupsS [gs:(List [String (List Int)]) q:/[]] =
  if (null gs) then q![]
  else ( new k:^[] ( printGroupSOneShot![(car gs) (rchan k)]
       | k?[] = printGroupsS![(cdr gs) q] ) )

{-============================
  10) Word search pipeline
============================-}

{- lowercase a char at i -}
def lowerAt [s:String i:Int q:/Char] =
  ( new ch:^Char
    ( string.nth![s i (rchan ch)]
    | ch?c:Char = char.toLower![c (rchan q)] ) )

{- lowercase whole string -}
def toLowerStr [s:String q:/String] =
  ( new n:^Int
    ( string.size![s (rchan n)]
    | n?L:Int =
        ( def f [i:Int q:/Char] = lowerAt![s i (rchan q)]
          string.tabulate![L f (rchan q)] ) ) )

{- case-insensitive contains via string.in after lowercasing -}
def containsSubstr [needle:String hay:String q:/Bool] =
  ( new nlow:^String new hlow:^String
    ( toLowerStr![needle (rchan nlow)]
    | toLowerStr![hay    (rchan hlow)]
    | nlow?n1:String = hlow?h1:String =
        string.in![n1 h1 (rchan q)] ) )

{- map: emit (wordLower, lineNo) for each token containing needle (case-insensitive) -}
def mapSearch [needle:String p:[Int String] q:/(List [String Int])] =
  ( val ln   = (fst p)
    val line = (snd p)
    new toks:^(List String)
    ( string.split![" ,;:.!?\t\n" line (rchan toks)]
    | toks?ws:(List String) =
        ( def go [xs:(List String) acc:(List [String Int]) q:/(List [String Int])] =
            if (null xs) then q!acc else
            ( val w = (car xs)
              new isEmpty:^Bool
              ( ==$![w "" (rchan isEmpty)]
              | isEmpty?e:Bool =
                  if e then go![(cdr xs) acc (rchan q)]
                  else
                    ( new wlow:^String
                      ( toLowerStr![w (rchan wlow)]
                      | wlow?wk:String =
                          ( new hit:^Bool
                            ( containsSubstr![needle w (rchan hit)]
                            | hit?ok:Bool =
                                if ok then
                                  go![(cdr xs) (cons [wk ln] acc) (rchan q)]
                                else
                                  go![(cdr xs) acc (rchan q)] ) ) ) ) ) )
          new acc:^(List [String Int])
          ( go![ws nil (rchan acc)]
          | acc?a:(List [String Int]) =
              ( new fwd:^(List [String Int])
                ( rev![#[String Int] a (rchan fwd)]
                | fwd?out:(List [String Int]) = q!out ) ) ) ) ) )

def mapSearchBound [p:[Int String] q:/(List [String Int])] =
  mapSearch![needle p (rchan q)]

{- reduce: keep sorted list of line numbers (dedup optional; we keep all) -}
def mergeInt [xs:(List Int) ys:(List Int) q:/(List Int)] =
  if (null xs) then q!ys
  else if (null ys) then q!xs
  else
    ( new le:^Bool
      ( <=![(car xs) (car ys) (rchan le)]
      | le?ok:Bool =
          if ok then
            ( new r:^(List Int)
              ( mergeInt![(cdr xs) ys (rchan r)]
              | r?rs:(List Int) = q!(cons (car xs) rs) ) )
          else
            ( new r:^(List Int)
              ( mergeInt![xs (cdr ys) (rchan r)]
              | r?rs:(List Int) = q!(cons (car ys) rs) ) ) ) )

def splitInt_go [ys:(List Int) a:(List Int) b:(List Int) q:/[(List Int) (List Int)]] =
  if (null ys) then q![a b]
  else if (null (cdr ys)) then q![(cons (car ys) a) b]
  else splitInt_go![(cdr (cdr ys)) (cons (car ys) a) (cons (car (cdr ys)) b) q]

def splitInt [xs:(List Int) q:/[(List Int) (List Int)]] =
  splitInt_go![xs nil nil (rchan q)]

def msortInt [xs:(List Int) q:/(List Int)] =
  if (null xs) then q!nil
  else if (null (cdr xs)) then q!xs
  else
    ( new halves:^[(List Int) (List Int)]
      ( splitInt![xs (rchan halves)]
      | halves?lr:[(List Int) (List Int)] =
          ( val left  = (fst lr)
            val right = (snd lr)
            new sl:^(List Int) new sr:^(List Int)
            ( msortInt![left  (rchan sl)]
            | msortInt![right (rchan sr)]
            | sl?l:(List Int) = sr?r:(List Int) = mergeInt![l r (rchan q)] ) ) ) )

def reduceKeepLines [g:[String (List Int)] q:/(List [String (List Int)])] =
  ( val w  = (fst g)
    val vs = (snd g)
    new svs:^(List Int)
    ( msortInt![vs (rchan svs)]
    | svs?sorted:(List Int) = q!(cons [w sorted] nil) ) )

{-============================
  11) Stats pipeline (optional)
============================-}

def wordCountLine [s:String q:/Int] =
  ( new toks:^(List String)
    ( string.split![" ,;:.!?\t\n" s (rchan toks)]
    | toks?ws:(List String) =
        ( def count [xs:(List String) acc:Int q:/Int] =
            if (null xs) then q!acc else
              ( new empty:^Bool
                ( ==$![(car xs) "" (rchan empty)]
                | empty?e:Bool =
                    if e then count![(cdr xs) acc (rchan q)]
                    else ( new acc1:^Int ( +![acc 1 (rchan acc1)] | acc1?n:Int = count![(cdr xs) n (rchan q)] ) ) ) )
          count![ws 0 (rchan q)] ) ) )

def tokenCharsLine [s:String q:/Int] =
  ( new toks:^(List String)
    ( string.split![" ,;:.!?\t\n" s (rchan toks)]
    | toks?ws:(List String) =
        ( def sumlen [xs:(List String) acc:Int q:/Int] =
            if (null xs) then q!acc else
              ( new empty:^Bool
                ( ==$![(car xs) "" (rchan empty)]
                | empty?e:Bool =
                    if e then sumlen![(cdr xs) acc (rchan q)]
                    else ( new n:^Int
                           ( string.size![(car xs) (rchan n)]
                           | n?k:Int =
                               ( new acc1:^Int ( +![acc k (rchan acc1)] | acc1?z:Int = sumlen![(cdr xs) z (rchan q)] ) ) ) ) ) )
          sumlen![ws 0 (rchan q)] ) ) )

def mapStats [p:[Int String] q:/(List [String [Int Int Int Int]])] =
  ( val s = (snd p)
    new c:^Int new w:^Int new tc:^Int
    ( string.size![s (rchan c)]
    | wordCountLine![s (rchan w)]
    | tokenCharsLine![s (rchan tc)]
    | c?chars:Int = w?words:Int = tc?tchars:Int =
        q!(cons ["stats" [chars words tchars 1]] nil) ) )

def reduceStats [g:[String (List [Int Int Int Int])] q:/(List [String Float])] =
  ( val vs = (snd g)
    def fold [xs:(List [Int Int Int Int]) acc:[Int Int Int Int] q:/[Int Int Int Int]] =
      if (null xs) then q!acc else
        ( val [c w t l]  = (car xs)
          val [C W T L]  = acc
          new C1:^Int new W1:^Int new T1:^Int new L1:^Int
          ( +![C c (rchan C1)]
          | +![W w (rchan W1)]
          | +![T t (rchan T1)]
          | +![L l (rchan L1)]
          | C1?Cc:Int = W1?Ww:Int = T1?Tt:Int = L1?Ll:Int =
              fold![(cdr xs) [Cc Ww Tt Ll] (rchan q)] ) )
    new totals:^[Int Int Int Int]
    ( fold![vs [0 0 0 0] (rchan totals)]
    | totals?[C W T L] =
        ( new tF:^Float new wF:^Float new lF:^Float
          ( float.fromInt![T (rchan tF)]
          | float.fromInt![W (rchan wF)]
          | float.fromInt![L (rchan lF)]
          | tF?t:Float = wF?w:Float = lF?l:Float =
              ( new cpw:^Float new wpl:^Float
                ( float.div![t w (rchan cpw)]
                | float.div![w l (rchan wpl)]
                | cpw?f1:Float = wpl?f2:Float =
                    ( new Cf:^Float new Wf:^Float
                      ( float.fromInt![C (rchan Cf)]
                      | float.fromInt![W (rchan Wf)]
                      | Cf?cF:Float = Wf?wF2:Float =
                          q!(cons ["Characters" cF]
                           (cons ["Characters per Word" f1]
                           (cons ["Words" wF2]
                           (cons ["Words per Line" f2] nil)))) ) ) ) ) ) ) ) )

{- label/float printing (for stats) -}
def printLabelFloat [p:[String Float] q:/[]] =
  ( val lab = (fst p)
    val valf = (snd p)
    new s:^String new line:^String
    ( float.toString![valf (rchan s)]
    | s?txt:String =
        ( +$![lab ": " (rchan line)]
        | line?a:String =
            ( new out:^String
              ( +$![a txt (rchan out)]
              | out?o:String = ( print!o | print!"\n" | q![] ) ) ) ) ) )

def printLabelFloatList [xs:(List [String Float]) q:/[]] =
  if (null xs) then q![]
  else ( new k:^[] ( printLabelFloat![(car xs) (rchan k)]
       | k?[] = printLabelFloatList![(cdr xs) (rchan q)] ) )

{-============================
  12) Main run: word search
============================-}

{-
new mapped:^(List [String Int])
new sorted:^(List [String Int])
new grouped:^(List [String (List Int)])
new reduced:^(List [String (List Int)])

run (
  {- 1) map (tokenize & filter by needle) -}
  flatMapIS![inputS mapSearchBound (rchan mapped)]

| {- 2) sort by (word length then lex) -}
  mapped?m:(List [String Int]) = msortPairsS![#Int m compareWordLen (rchan sorted)]

| {- 3) group by word -}
  sorted?s:(List [String Int]) = groupByKeyS![#Int s (rchan grouped)]

| {- 4) reduce: sort line numbers per word -}
  grouped?g:(List [String (List Int)]) = flatMapGroupsS![#Int #(List Int) g reduceKeepLines (rchan reduced)]

| {- 5) print nicely -}
  reduced?out:(List [String (List Int)]) =
    ( print!"matches:\n"
    | ( new done:^[]
      ( printGroupsS![out (rchan done)]
      | done?[] = print!"--end--\n" ) ) )
)


new stats:^(List [String [Int Int Int Int]])
new groupedS:^(List [String (List [Int Int Int Int])])
new out2:^(List [String Float])
run (
  flatMapFromIS![#[Int Int Int Int] inputS mapStats (rchan stats)]
| stats?m:(List [String [Int Int Int Int]]) = groupByKeyS![#[Int Int Int Int] m (rchan groupedS)]
| groupedS?g:(List [String (List [Int Int Int Int])]) =
    flatMapGroupsS![#[Int Int Int Int] #Float g reduceStats (rchan out2)]
| out2?final:(List [String Float]) =
    ( print!"stats:\n"
    | ( new done:^[]
        ( printLabelFloatList![final (rchan done)]
        | done?[] = print!"--end--\n" ) ) )
) -}
