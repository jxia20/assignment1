import "Std/Prim"
import "Std/List"
import "Std/String"
import "Std/Int"
import "Std/Array"
import "Std/Char"

{- charAt s idx q:
   SHOULD send the 1-character string at position idx in s,
   or "" if idx is out of range.
   CURRENTLY A STUB. You will replace the body once you know
   the real primitive from Std/String or Std/Char.
-}
def charAt [s:String idx:Int q:/String] =
  q!""

def strlen_loop [s:String i:Int q:/Int] =
  ( new ch:^String
    ( charAt![s i (rchan ch)]
    | ch?c:String =
        ( new empty:^Bool
          ( ==$![c "" (rchan empty)]
          | empty?isEmpty:Bool =
              if isEmpty then
                q!i
              else
                ( new i1:^Int
                  ( +![i 1 (rchan i1)]
                  | i1?nxt:Int =
                      strlen_loop![s nxt (rchan q)] ) ) ) ) ) )

def strlen [s:String q:/Int] =
  strlen_loop![s 0 (rchan q)]

def sub_loop [s:String idx:Int remaining:Int acc:String q:/String] =
  ( new done:^Bool
    ( compareInt![remaining 0 (rchan done)]     {- remaining <= 0 ? -}
    | done?stop:Bool =
        if stop then
          q!acc
        else
          ( new ch:^String
            ( charAt![s idx (rchan ch)]
            | ch?c:String =
                ( new empty:^Bool
                  ( ==$![c "" (rchan empty)]
                  | empty?isEmpty:Bool =
                      if isEmpty then
                        {- ran off end of s -}
                        q!acc
                      else
                        ( new acc2:^String
                          ( +$![acc c (rchan acc2)]
                          | acc2?accNext:String =
                              ( new idx1:^Int
                                new rem1:^Int
                                ( +![idx 1 (rchan idx1)]
                                | -![remaining 1 (rchan rem1)]
                                | idx1?nextIdx:Int = rem1?nextRem:Int =
                                    sub_loop![s nextIdx nextRem accNext (rchan q)] ) ) ) ) ) ) ) ) ) )
def sub [s:String start:Int len:Int q:/String] =
  sub_loop![s start len "" (rchan q)]
  
{- append helper function. combines two lists -}
def append [#X xs:(List X) ys:(List X) q:/(List X)] =
  if (null xs) then
    q!ys
  else
    ( new k:^(List X)
      ( append![#X (cdr xs) ys (rchan k)]
      | k?zs:(List X) = q!(cons (car xs) zs) ))

{- appendPairs: ∀T. append (List [Int T]) ++ (List [Int T]) -}
def appendPairs [#T xs:(List [Int T]) ys:(List [Int T]) q:/(List [Int T])] =
  if (null xs) then
    q!ys
  else
    ( new k:^(List [Int T])
      ( appendPairs![#T (cdr xs) ys (rchan k)]
      | k?zs:(List [Int T]) = q!(cons (car xs) zs) ))

{- printer list helper function. prints all values of a list of type integer -}
def printList xs:(List Int) =
  if (null xs) then
    print!"\n"
  else
    ( printi!(car xs)
    | print!" "
    | printList!(cdr xs) )

{- reverse list helper function. reverses a list -}
def revAcc [#X xs:(List X) acc:(List X) q:/(List X)] =
  if (null xs) then
    q!acc
  else
    revAcc![#X (cdr xs) (cons (car xs) acc) q]

{- reverse list helper -}
def rev [#X xs:(List X) q:/(List X)] =
  revAcc![#X xs nil q]

def lengthAcc [#X xs:(List X) n:Int q:/Int] =
  if (null xs) then
    q!n
  else
    ( new sum:^Int
      ( +![n 1 (rchan sum)]            
      | sum?np1:Int = lengthAcc![#X (cdr xs) np1 q] ))

def length [#X xs:(List X) q:/Int] =
  lengthAcc![#X xs 0 q]

{- mapList: apply f to each element of xs, collect results in order, send on q -}
def mapList [#A #B xs:(List A) f:/[A /B] q:/(List B)] =
  if (null xs) then
    q!nil
  else
    ( new b:^B            {- result of f (car xs) -}
      new tl:^(List B)    {- mapped tail -}
      ( f![(car xs) (rchan b)]
      | b?y:B =
          ( mapList![#A #B (cdr xs) f (rchan tl)]
          | tl?ys:(List B) = q!(cons y ys) ) ) )

{- flatMap: ∀A,B. f : A -> (List B); concatenate f(x) over xs, send (List B) on q -}
def flatMap [#A #B xs:(List A) f:/[A /(List B)] q:/(List B)] =
  if (null xs) then
    q!nil
  else
    ( new h:^(List B)      {- result of f (car xs) -}
      new t:^(List B)      {- flatMap result of tail -}
      new a:^(List B)      {- combined list -}
      ( f![(car xs) (rchan h)]
      | flatMap![#A #B (cdr xs) f (rchan t)]
      | h?hs:(List B) = t?ts:(List B) =     {- receive both before appending -}
          append![#B hs ts (rchan a)]
      | a?res:(List B) = q!res ) )
      
{- flatMap over pairs: xs : (List [Int V]), f : [Int V] -> (List [Int V]) -}
def flatMapPairs [#V xs:(List [Int V]) f:/[[Int V] /(List [Int V])] q:/(List [Int V])] =
  if (null xs) then
    q!nil
  else
    ( new h:^(List [Int V])
      new t:^(List [Int V])
      new a:^(List [Int V])
      ( f![(car xs) (rchan h)]
      | flatMapPairs![#V (cdr xs) f (rchan t)]
      | h?hs:(List [Int V]) = t?ts:(List [Int V]) =
          appendPairs![#V hs ts (rchan a)]
      | a?res:(List [Int V]) = q!res ) )

{- flatMap over groups: xs : (List [Int (List V)]), f : [Int (List V)] -> (List [Int W]) -}
def flatMapGroups [#V #W xs:(List [Int (List V)]) f:/[[Int (List V)] /(List [Int W])] q:/(List [Int W])] =
  if (null xs) then
    q!nil
  else
    ( new h:^(List [Int W])
      new t:^(List [Int W])
      new a:^(List [Int W])
      ( f![(car xs) (rchan h)]
      | flatMapGroups![#V #W (cdr xs) f (rchan t)]
      | h?hs:(List [Int W]) = t?ts:(List [Int W]) =
          appendPairs![#W hs ts (rchan a)]
      | a?res:(List [Int W]) = q!res ) )

{- mergePairs: merge two key-sorted lists of [Int V] using cmp, send result on q -}
def mergePairs [#V xs:(List [Int V]) ys:(List [Int V]) cmp:/[Int Int /Bool] q:/(List [Int V])] =
  if (null xs) then q!ys
  else if (null ys) then q!xs
  else
    ( val [kx vx] = (car xs)
      val [ky vy] = (car ys)
      new le:^Bool
      ( cmp![kx ky (rchan le)]
      | le?isLE:Bool =
          if isLE then
            ( new rest:^(List [Int V])
              ( mergePairs![#V (cdr xs) ys cmp (rchan rest)]
              | rest?rs:(List [Int V]) = q!(cons [kx vx] rs) ) )
          else
            ( new rest:^(List [Int V])
              ( mergePairs![#V xs (cdr ys) cmp (rchan rest)]
              | rest?rs:(List [Int V]) = q!(cons [ky vy] rs) ) ) ) )

{- tail helper: alternate elements into a and b, then send both -}
def splitPairs_go [#V ys:(List [Int V]) a:(List [Int V]) b:(List [Int V]) q:/[(List [Int V]) (List [Int V])]] =
  if (null ys) then
    q![a b]
  else if (null (cdr ys)) then
    q![(cons (car ys) a) b]
  else
    splitPairs_go![#V (cdr (cdr ys)) (cons (car ys) a) (cons (car (cdr ys)) b) q]

{- entry point -}
def splitPairs [#V xs:(List [Int V]) q:/[(List [Int V]) (List [Int V])]] =
  splitPairs_go![#V xs nil nil q]

def msortPairs [#V xs:(List [Int V]) cmp:/[Int Int /Bool] q:/(List [Int V])] =
  if (null xs) then
    q!nil
  else if (null (cdr xs)) then
    q!xs
  else
    ( new halves:^[(List [Int V]) (List [Int V])]
      ( splitPairs![#V xs (rchan halves)]
      | halves?lr:[(List [Int V]) (List [Int V])] =
          ( val left  = (fst lr)
            val right = (snd lr)
            new sl:^(List [Int V])
            new sr:^(List [Int V])
            new m:^(List [Int V])
            ( msortPairs![#V left  cmp (rchan sl)]
            | msortPairs![#V right cmp (rchan sr)]
            | sl?l:(List [Int V]) = sr?r:(List [Int V]) =
                mergePairs![#V l r cmp (rchan m)]
            | m?res:(List [Int V]) = q!res ) ) ))

{- print one tuple [Int Int] as (k:v) followed by a space -}
def printPairKV p:[Int Int] =
  ( val [k v] = p
      ( printi!k |
        ( print!":" | 
          ( printi!v |
            print!"" ) ) ) )
  
{- print a list of [Int Int] -}
def printPairsKV xs:(List [Int Int]) =
  if (null xs) then
    print!"\n"
  else
    ( printPairKV!(car xs) 
      | printPairsKV!(cdr xs) )
    
{- dup: make a 2-element list [x, x] -}
def dup [x:Int q:/(List Int)] =
  q!(cons x (cons x nil))
  
{- inc: x ↦ x + 1, returning via q -}
def increment [x:Int q:/Int] =
  ( new s:^Int
    ( +![x 1 (rchan s)]
    | s?r:Int = q!r ))

{- compareInt: send (x <= y) on q -}
def compareInt [x:Int y:Int q:/Bool] =
  ( new b:^Bool
    ( <=![x y (rchan b)]
    | b?res = q!res ) )

{- eqInt : send (x == y) on q -}
def eqInt [x:Int y:Int q:/Bool] =
  ( new b:^Bool
    ( ==![x y (rchan b)]
    | b?res = q!res ) )

{- collectSameKey: given a sorted list ys of [Int V], collect a maximal run of 'key' into acc
   and return the (values, rest) on TWO channels: qa for values (in reverse), qb for rest. -}
def collectSameKey [#V ys:(List [Int V]) key:Int acc:(List V)
                    qa:/(List V) qb:/(List [Int V])] =
  if (null ys) then
    ( qa!acc | qb!nil )
  else
    ( val p = (car ys)
      val k = (fst p)
      val v = (snd p)
      new eq:^Bool
      ( eqInt![key k (rchan eq)]
      | eq?same:Bool =
          if same then
            collectSameKey![#V (cdr ys) key (cons v acc) qa qb]
          else
            ( qa!acc | qb!ys ) ) )

{- groupByKey: input must be sorted by key; produce [k (List V in original order)] -}
def groupByKey [#V xs:(List [Int V]) q:/(List [Int (List V)])] =
  if (null xs) then
    q!nil
  else
    ( val p0 = (car xs)
      val k0 = (fst p0)
      val v0 = (snd p0)

      new vals:^(List V)            
      new rest:^(List [Int V])      

      ( collectSameKey![#V (cdr xs) k0 (cons v0 nil) (rchan vals) (rchan rest)]
      | vals?revVals:(List V) =
          ( new fwd:^(List V)
            ( rev![#V revVals (rchan fwd)]
            | fwd?vs:(List V) =
                rest?rem:(List [Int V]) =
                  ( new tail:^(List [Int (List V)])
                    ( groupByKey![#V rem (rchan tail)]
                    | tail?gs:(List [Int (List V)]) =
                        q!(cons [k0 vs] gs) ) ) ) ) ) )

{- print a grouped item [Int (List Int)] as k:[v1 v2 ...] -}
def printGroup g:[Int (List Int)] =
  ( val [k vs] = g
    ( printi!k
    | printList!vs
    )
  )

def printGroups gs:(List [Int (List Int)]) =
  if (null gs) then print!""
  else ( printGroup!(car gs) | printGroups!(cdr gs) )

{- printListSync: print a (List Int) then signal when done -}
def printListSync [xs:(List Int) q:/[]] =
  if (null xs) then
    q![]
  else
    ( printi!(car xs)
    | print!" "
    | printListSync![(cdr xs) q] )

{- printGroupSync: print one group k:[v1 v2 ...] + newline, then ack -}
def printGroupSync [g:[Int (List Int)] q:/[]] =
  ( val [k vs] = g
    ( printi!k
    | print!":" 
    | ( new done:^[]
        ( printListSync![vs (rchan done)]
        | done?[] = ( print!"\n" | q![] ) ) ) ) )

{- printGroupsSync: print groups sequentially by waiting for each ack -}
def printGroupsSync [gs:(List [Int (List Int)]) q:/[]] =
  if (null gs) then q![]
  else
    ( new k:^[]
      ( printGroupSync![(car gs) (rchan k)]
      | k?[] = printGroupsSync![(cdr gs) q] ) )

{- mapReduce (Int keys):1) flatMap mapF over input2) sort by cmp3) group by key4) flatMap reduceF over groups-> send final (List [Int W]) on q-}
def mapReduce [#V #W
              mapF:/[[Int V] /(List [Int V])]
              cmp:/[Int Int /Bool]
              reduceF:/[[Int (List V)] /(List [Int W])]
              input:(List [Int V]) q:/(List [Int W])] =
  ( new mapped:^(List [Int V])
    new sorted:^(List [Int V])
    new grouped:^(List [Int (List V)])
    new reduced:^(List [Int W])

    {- 1) flatMap mapF over input -}
    ( flatMapPairs![#V input mapF (rchan mapped)]

    {- 2) sort by key -}
    | mapped?m:(List [Int V]) =
        msortPairs![#V m cmp (rchan sorted)]

    {- 3) group -}
    | sorted?s:(List [Int V]) =
        groupByKey![#V s (rchan grouped)]

    {- 4) flatMap reduceF over groups -}
    | grouped?g:(List [Int (List V)]) =
        flatMapGroups![#V #W g reduceF (rchan reduced)]

    {- done -}
    | reduced?out:(List [Int W]) = q!out ) )

{- test map: duplicate each pair (k,v) -> [(k,v),(k,v)] -}
def mapDup [p:[Int Int] q:/(List [Int Int])] =
  ( val [k v] = p
  q!(cons [k v] (cons [k v] nil)) )

{- sum a list of Ints, sending the result on r -}
def sumList [xs:(List Int) r:/Int] =
  if (null xs) then
    r!0
  else
    ( new t:^Int
      ( sumList![(cdr xs) (rchan t)]
      | t?s:Int = +![(car xs) s (rchan r)] ))

{- reduceSum: sum values per key → single pair [k, sum] inside a 1-element list -}
def reduceSum [g:[Int (List Int)] q:/(List [Int Int])] =
  ( val [k vs] = g
    new s:^Int
    ( sumList![vs (rchan s)]
    | s?total:Int = q!(cons [k total] nil) ))

{- appendPairsS: ∀T. append two (List [String T]) -}
def appendPairsS [#T xs:(List [String T]) ys:(List [String T]) q:/(List [String T])] =
  if (null xs) then q!ys
  else
    ( new k:^(List [String T])
      ( appendPairsS![#T (cdr xs) ys (rchan k)]
      | k?zs:(List [String T]) = q!(cons (car xs) zs) ))

{- flatMapPairsS: xs : (List [String V]), f : [String V] -> (List [String V]) -}
def flatMapPairsS [#V xs:(List [String V]) f:/[[String V] /(List [String V])] q:/(List [String V])] =
  if (null xs) then q!nil
  else
    ( new h:^(List [String V]) new t:^(List [String V]) new a:^(List [String V])
      ( f![(car xs) (rchan h)]
      | flatMapPairsS![#V (cdr xs) f (rchan t)]
      | h?hs:(List [String V]) = t?ts:(List [String V]) =
          appendPairsS![#V hs ts (rchan a)]
      | a?res:(List [String V]) = q!res ) )

{- mergePairsS: merge two key-sorted lists of [String V] using cmp(String<=), send on q -}
def mergePairsS [#V xs:(List [String V]) ys:(List [String V]) cmp:/[String String /Bool] q:/(List [String V])] =
  if (null xs) then q!ys
  else if (null ys) then q!xs
  else
    ( val px = (car xs)  val py = (car ys)
      val kx = (fst px)  val ky = (fst py)
      val vx = (snd px)  val vy = (snd py)
      new le:^Bool
      ( cmp![kx ky (rchan le)]
      | le?isLE:Bool =
          if isLE then
            ( new rest:^(List [String V])
              ( mergePairsS![#V (cdr xs) ys cmp (rchan rest)]
              | rest?rs:(List [String V]) = q!(cons [kx vx] rs) ) )
          else
            ( new rest:^(List [String V])
              ( mergePairsS![#V xs (cdr ys) cmp (rchan rest)]
              | rest?rs:(List [String V]) = q!(cons [ky vy] rs) ) ) ) )

{- splitPairsS: alternate elements into a and b, then send both in a tuple -}
def splitPairsS_go [#V ys:(List [String V]) a:(List [String V]) b:(List [String V]) q:/[(List [String V]) (List [String V])]] =
  if (null ys) then q![a b]
  else if (null (cdr ys)) then q![(cons (car ys) a) b]
  else
    splitPairsS_go![#V (cdr (cdr ys)) (cons (car ys) a) (cons (car (cdr ys)) b) q]

def splitPairsS [#V xs:(List [String V]) q:/[(List [String V]) (List [String V])]] =
  splitPairsS_go![#V xs nil nil q]

{- msortPairsS: merge-sort by String key using cmp -}
def msortPairsS [#V xs:(List [String V]) cmp:/[String String /Bool] q:/(List [String V])] =
  if (null xs) then q!nil
  else if (null (cdr xs)) then q!xs
  else
    ( new halves:^[(List [String V]) (List [String V])]
      ( splitPairsS![#V xs (rchan halves)]
      | halves?lr:[(List [String V]) (List [String V])] =
          ( val left  = (fst lr)
            val right = (snd lr)
            new sl:^(List [String V]) new sr:^(List [String V]) new m:^(List [String V])
            ( msortPairsS![#V left  cmp (rchan sl)]
            | msortPairsS![#V right cmp (rchan sr)]
            | sl?l:(List [String V]) = sr?r:(List [String V]) =
                mergePairsS![#V l r cmp (rchan m)]
            | m?res:(List [String V]) = q!res ) ) ))

def eqStr [x:String y:String q:/Bool] =
  ( new b:^Bool
    ( ==$![x y (rchan b)]
    | b?res = q!res ) )
        
{- collectSameKeyS: like Int version, but for String keys (returns two channels) -}
def collectSameKeyS [#V ys:(List [String V]) key:String acc:(List V) qa:/(List V) qb:/(List [String V])] =
  if (null ys) then ( qa!acc | qb!nil )
  else
    ( val p = (car ys)  val k = (fst p)  val v = (snd p)
      new eq:^Bool
      ( eqStr![key k (rchan eq)]
      | eq?same:Bool =
          if same then
            collectSameKeyS![#V (cdr ys) key (cons v acc) qa qb]
          else
            ( qa!acc | qb!ys ) ) )

def groupByKeyS [#V xs:(List [String V]) q:/(List [String (List V)])] =
  if (null xs) then q!nil
  else
    ( val p0 = (car xs)  val k0 = (fst p0)  val v0 = (snd p0)
      new vals:^(List V) new rest:^(List [String V])
      ( collectSameKeyS![#V (cdr xs) k0 (cons v0 nil) (rchan vals) (rchan rest)]
      | vals?revVals:(List V) =
          ( new fwd:^(List V)
            ( rev![#V revVals (rchan fwd)]
            | fwd?vs:(List V) =
                rest?rem:(List [String V]) =
                  ( new tail:^(List [String (List V)])
                    ( groupByKeyS![#V rem (rchan tail)]
                    | tail?gs:(List [String (List V)]) = q!(cons [k0 vs] gs) ) ) ) ) ) )

{- flatMapGroupsS: groups [String (List V)] via f : … -> (List [String W]) -}
def flatMapGroupsS [#V #W xs:(List [String (List V)]) f:/[[String (List V)] /(List [String W])] q:/(List [String W])] =
  if (null xs) then q!nil
  else
    ( new h:^(List [String W]) new t:^(List [String W]) new a:^(List [String W])
      ( f![(car xs) (rchan h)]
      | flatMapGroupsS![#V #W (cdr xs) f (rchan t)]
      | h?hs:(List [String W]) = t?ts:(List [String W]) =
          appendPairsS![#W hs ts (rchan a)]
      | a?res:(List [String W]) = q!res ) )

{- mapReduceS for String keys: map -> sort -> group -> reduce -}
def mapReduceS [#V #W
               mapF:/[[String V] /(List [String V])]
               cmp:/[String String /Bool]
               reduceF:/[[String (List V)] /(List [String W])]
               input:(List [String V]) q:/(List [String W])] =
  ( new mapped:^(List [String V])
    new sorted:^(List [String V])
    new grouped:^(List [String (List V)])
    new reduced:^(List [String W])
    ( flatMapPairsS![#V input mapF (rchan mapped)]
    | mapped?m:(List [String V]) = msortPairsS![#V m cmp (rchan sorted)]
    | sorted?s:(List [String V]) = groupByKeyS![#V s (rchan grouped)]
    | grouped?g:(List [String (List V)]) = flatMapGroupsS![#V #W g reduceF (rchan reduced)]
    | reduced?out:(List [String W]) = q!out ) )

{- concat a (List String) with no separator -}
def concatStrings [xs:(List String) q:/String] =
  if (null xs) then
    q!""
  else
    ( new rest:^String
      ( concatStrings![(cdr xs) (rchan rest)]
      | rest?rs:String =
          ( new c:^String
            ( +$![(car xs) rs (rchan c)]
            | c?z:String = q!z ) ) ) )

val inputS =
  (cons [1  "WHEN I consider how my light is spent"]
  (cons [2  "  E're half my days, in this dark world and wide,"]
  (cons [3  "  And that one Talent which is death to hide,"]
  (cons [4  "  Lodg'd with me useless, though my Soul more bent"]
  (cons [5  "To serve therewith my Maker, and present"]
  (cons [6  "  My true account, least he returning chide,"]
  (cons [7  "  Doth God exact day-labour, light deny'd,"]
  (cons [8  "  I fondly ask; But patience to prevent"]
  (cons [9  "That murmur, soon replies, God doth not need"]
  (cons [10 "  Either man's work or his own gifts, who best"]
  (cons [11 "  Bear his milde yoak, they serve him best, his State"]
  (cons [12 "Is Kingly. Thousands at his bidding speed"]
  (cons [13 "  And post o're Land and Ocean without rest:"]
  (cons [14 "  They also serve who only stand and waite."]
        nil))))))))))))))

val needle = "is"

def compareWordLen [a:String b:String q:/Bool] =
  ( new la:^Int
    new lb:^Int
    ( strlen![a (rchan la)]
    | strlen![b (rchan lb)]
    | la?na:Int = lb?nb:Int =
        ( new sameLen:^Bool
          ( eqInt![na nb (rchan sameLen)]
          | sameLen?eqL:Bool =
              if eqL then
                {- same length: fall back to lexicographic a <= b -}
                ( new lex:^Bool
                  ( <=$![a b (rchan lex)]
                  | lex?ok:Bool = q!ok ) )
              else
                {- different lengths: just compare lengths na <= nb -}
                ( new le:^Bool
                  ( compareInt![na nb (rchan le)]
                  | le?ok2:Bool = q!ok2 ) ) ) ) ) )

def isPunctChar [c:String q:/Bool] =
  ( new b1:^Bool
    ( ==$![c "," (rchan b1)]
    | b1?comma:Bool =
        if comma then
          q!true
        else
          ( new b2:^Bool
            ( ==$![c ";" (rchan b2)]
            | b2?semi:Bool =
                if semi then
                  q!true
                else
                  ( new b3:^Bool
                    ( ==$![c "." (rchan b3)]
                    | b3?dot:Bool =
                        if dot then
                          q!true
                        else
                          ( new b4:^Bool
                            ( ==$![c ":" (rchan b4)]
                            | b4?colon:Bool =
                                if colon then q!true else q!false ) ) ) ) ) ) ) )

def stripPunctLoop [s:String n:Int q:/String] =
  ( new isZero:^Bool
    ( eqInt![n 0 (rchan isZero)]
    | isZero?z:Bool =
        if z then
          q!s
        else
          ( new n1:^Int
            ( -![n 1 (rchan n1)]
            | n1?idx:Int =
                ( new lastChar:^String
                  ( sub![s idx 1 (rchan lastChar)]
                  | lastChar?ch:String =
                      ( new isp:^Bool
                        ( isPunctChar![ch (rchan isp)]
                        | isp?pun:Bool =
                            if pun then
                              ( new prefix:^String
                                ( sub![s 0 idx (rchan prefix)]
                                | prefix?pref:String =
                                    stripPunctLoop![pref idx (rchan q)] ) )
                            else
                              q!s ) ) ) ) ) ) ) )

def stripPunct [s:String q:/String] =
  ( new n:^Int
    ( strlen![s (rchan n)]
    | n?len:Int =
        stripPunctLoop![s len (rchan q)] ) )

def finishSplitWords [acc:(List String) curr:String q:/(List String)] =
  ( new emptyCurr:^Bool
    ( eqStr![curr "" (rchan emptyCurr)]
    | emptyCurr?isEmpty:Bool =
        ( new revIn:^(List String)
          ( if isEmpty then
              rev![#String acc (rchan revIn)]
            else
              rev![#String (cons curr acc) (rchan revIn)]
          | revIn?out:(List String) = q!out ) ) ) )
def splitWords_loop [s:String len:Int i:Int curr:String acc:(List String) q:/(List String)] =
  ( new atEnd:^Bool
    ( eqInt![i len (rchan atEnd)]
    | atEnd?done:Bool =
        if done then
          finishSplitWords![acc curr (rchan q)]
        else
          ( new ch:^String
            ( sub![s i 1 (rchan ch)]
            | ch?c:String =
                ( new isSpace:^Bool
                  ( ==$![c " " (rchan isSpace)]
                  | isSpace?sp:Bool =
                      if sp then
                        {- we hit a space: flush curr (if not empty) into acc, reset curr="" -}
                        ( new emptyCurr:^Bool
                          ( eqStr![curr "" (rchan emptyCurr)]
                          | emptyCurr?e:Bool =
                              ( new acc2:^(List String)
                                ( if e then
                                    acc2!acc
                                  else
                                    acc2!(cons curr acc)
                                | acc2?a2:(List String) =
                                    ( new ip1:^Int
                                      ( +![i 1 (rchan ip1)]
                                      | ip1?i1:Int =
                                          splitWords_loop![s len i1 "" a2 (rchan q)] ) ) ) ) ) )
                      else
                        {- normal char: append to curr, continue -}
                        ( new newCurr:^String
                          ( +$![curr c (rchan newCurr)]
                          | newCurr?nc:String =
                              ( new ip1:^Int
                                ( +![i 1 (rchan ip1)]
                                | ip1?i1:Int =
                                    splitWords_loop![s len i1 nc acc (rchan q)] ) ) ) ) ) ) ) ) ) )
def splitWords [s:String q:/(List String)] =
  ( new len:^Int
    ( strlen![s (rchan len)]
    | len?n:Int =
        splitWords_loop![s n 0 "" nil (rchan q)] ) )

def containsFromOffset [needle:String hay:String mlen:Int i:Int limit:Int q:/Bool] =
  ( new within:^Bool
    ( compareInt![i limit (rchan within)]   {- i <= limit ? -}
    | within?okWithin:Bool =
        if okWithin then
          ( new seg:^String
            ( sub![hay i mlen (rchan seg)]
            | seg?chunk:String =
                ( new eq:^Bool
                  ( ==$![chunk needle (rchan eq)]
                  | eq?match:Bool =
                      if match then
                        q!true
                      else
                        ( new ip1:^Int
                          ( +![i 1 (rchan ip1)]
                          | ip1?nextI:Int =
                              containsFromOffset![needle hay mlen nextI limit (rchan q)] ) ) ) ) ) )
        else
          q!false ) )

def containsSubstr [needle:String hay:String q:/Bool] =
  ( new m:^Int
    new n:^Int
    ( strlen![needle (rchan m)]
    | strlen![hay (rchan n)]
    | m?mlen:Int = n?nlen:Int =
        ( new diff:^Int
          ( -![nlen mlen (rchan diff)]
          | diff?limit:Int =
              containsFromOffset![needle hay mlen 0 limit (rchan q)] ) ) ) )

def mapSearchWords [needle:String ws:(List String) ln:Int q:/(List [String Int])] =
  if (null ws) then
    q!nil
  else
    ( new cleaned:^String
      new tail:^(List [String Int])
      ( stripPunct![(car ws) (rchan cleaned)]
      | mapSearchWords![needle (cdr ws) ln (rchan tail)]
      | cleaned?cw:String =
          ( new hit:^Bool
            ( containsSubstr![needle cw (rchan hit)]
            | hit?ok:Bool =
                tail?ts:(List [String Int]) =
                  if ok then
                    q!(cons [cw ln] ts)
                  else
                    q!ts ) ) ) )

def mapSearch [needle:String p:[Int String] q:/(List [String Int])] =
  ( val ln   = (fst p)     {- line number -}
    val line = (snd p)     {- line text   -}
    new words:^(List String)
    ( splitWords![line (rchan words)]
    | words?ws:(List String) =
        mapSearchWords![needle ws ln (rchan q)] ) )

def mapSearchBound [p:[Int String] q:/(List [String Int])] =
  mapSearch![needle p (rchan q)]
  
def reduceKeepLines [g:[String (List Int)] q:/(List [String (List Int)])] =
  q!(cons g nil)

def printIntListInline [xs:(List Int) q:/[]] =
  if (null xs) then q![]
  else ( printi!(car xs) | print!" " | printIntListInline![(cdr xs) q] )

def printGroupS [g:[String (List Int)] q:/[]] =
  ( print!(fst g) | print!": "
  | (new done:^[]
    ( printIntListInline![(snd g) (rchan done)]
    | done?[] = ( print!"\n" | q![] ) ) ))

def printGroupsS [gs:(List [String (List Int)]) q:/[]] =
  if (null gs) then q![]
  else
    ( new k:^[]
      ( printGroupS![(car gs) (rchan k)]
      | k?[] = printGroupsS![(cdr gs) q] ) )

new out:^String
run (
  stripPunct!["wide," (rchan out)]
| out?cleaned:String =
    ( print!"stripPunct wide,: "
    | print!cleaned
    | print!"\n" )
)