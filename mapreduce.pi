import "Std/List"
import "Std/Int"
import "Std/String"

{- append two lists -}
def append (xs ys) =
  if (null xs) then ys else (cons (car xs) (append (cdr xs) ys))

{- map over a list -}
def mapList (f xs) =
  if (null xs) then nil else (cons (f (car xs)) (mapList f (cdr xs)))

{- flatMap: f : X -> (List Y), then concat -}
def flatMap (f xs) =
  if (null xs) then nil else append (f (car xs)) (flatMap f (cdr xs))

{- split list into two lists (for mergesort) -}
def split2 (xs) =
  if (null xs) then [nil nil]
  else if (null (cdr xs)) then [(cons (car xs) nil) nil]
  else
    ( let tail = split2 (cdr (cdr xs)) in
      [(cons (car xs) (fst tail)) (cons (car (cdr xs)) (snd tail))] )

{- merge two sorted lists of pairs [K V], using compare on keys -}
def mergePairs (compare xs ys) =
  if (null xs) then ys
  else if (null ys) then xs
  else
    ( let x = (car xs) in
      let y = (car ys) in
      let kx = (fst x) in
      let ky = (fst y) in
      if (compare kx ky) then
        (cons x (mergePairs compare (cdr xs) ys))
      else
        (cons y (mergePairs compare xs (cdr ys))) )

{- mergesort for [K V] using compare : K -> K -> Bool -}
def mergeSortPairs (compare xs) =
  if (null xs) then nil
  else if (null (cdr xs)) then xs
  else
    ( let halves = split2 xs in
      let a = (fst halves) in
      let b = (snd halves) in
      mergePairs compare (mergeSortPairs compare a) (mergeSortPairs compare b) )

{- group adjacent [K V] into [K (List V)]. xs must be sorted by K -}
def groupByKeySorted (xs) =
  if (null xs) then nil
  else
    ( let p0 = (car xs) in
      let k0 = (fst p0) in
      let v0 = (snd p0) in
      let taken = takeSameKey k0 (cdr xs) (cons v0 nil) in
      let rest = (fst taken) in
      let vals = (snd taken) in
      (cons [k0 (rev vals)] (groupByKeySorted rest)) )

{- helper: consume as many leading [K V] with same key as k0 -}
def takeSameKey (k0 xs acc) =
  if (null xs) then [nil acc]
  else
    ( let p = (car xs) in
      if (== (fst p) k0) then
        takeSameKey k0 (cdr xs) (cons (snd p) acc)
      else
        [xs acc] )

{- reverse (simple) -}
def revAcc (xs acc) = if (null xs) then acc else revAcc (cdr xs) (cons (car xs) acc)
def rev (xs) = revAcc xs nil

{- The MapReduce engine
   map     : K1 -> V1 -> (List [K2 V2])
   compare : K2 -> K2 -> Bool
   reduce  : K2 -> (List V2) -> (List V3)
   input   : (List [K1 V1])
   returns : (List V3)
-}

def mapReduce (map compare reduce input) =
  let mapped = flatMap (\p . map (fst p) (snd p)) input in
  let sorted = mergeSortPairs compare mapped in
  let groups = groupByKeySorted sorted in
  flatMap (\g . reduce (fst g) (snd g)) groups