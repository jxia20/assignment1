import "Std/List"
import "Std/String"
import "Std/Int"
import "Std/Array"

{- append helper function. combines two lists -}
def append [#X xs:(List X) ys:(List X) q:/(List X)] =
  if (null xs) then
    q!ys
  else
    ( new k:^(List X)
      ( append![#X (cdr xs) ys (rchan k)]
      | k?zs:(List X) = q!(cons (car xs) zs) ))

{- printer list helper function. prints all values of a list of type integer -}
def printList xs:(List Int) =
  if (null xs) then
    print!"\n"
  else
    ( printi!(car xs)
    | print!" "
    | printList!(cdr xs) )

{- reverse list helper function. reverses a list -}
def revAcc [#X xs:(List X) acc:(List X) q:/(List X)] =
  if (null xs) then
    q!acc
  else
    revAcc![#X (cdr xs) (cons (car xs) acc) q]

{- reverse list helper -}
def rev [#X xs:(List X) q:/(List X)] =
  revAcc![#X xs nil q]

def lengthAcc [#X xs:(List X) n:Int q:/Int] =
  if (null xs) then
    q!n
  else
    ( new sum:^Int
      ( +![n 1 (rchan sum)]            
      | sum?np1:Int = lengthAcc![#X (cdr xs) np1 q] ))

def length [#X xs:(List X) q:/Int] =
  lengthAcc![#X xs 0 q]

{- mapList: apply f to each element of xs, collect results in order, send on q -}
def mapList [#A #B xs:(List A) f:/[A /B] q:/(List B)] =
  if (null xs) then
    q!nil
  else
    ( new b:^B            {- result of f (car xs) -}
      new tl:^(List B)    {- mapped tail -}
      ( f![(car xs) (rchan b)]
      | b?y:B =
          ( mapList![#A #B (cdr xs) f (rchan tl)]
          | tl?ys:(List B) = q!(cons y ys) ) ) )

{- flatMap: ∀A,B. f : A -> (List B); concatenate f(x) over xs, send (List B) on q -}
def flatMap [#A #B xs:(List A) f:/[A /(List B)] q:/(List B)] =
  if (null xs) then
    q!nil
  else
    ( new h:^(List B)      {- result of f (car xs) -}
      new t:^(List B)      {- flatMap result of tail -}
      new a:^(List B)      {- combined list -}
      ( f![(car xs) (rchan h)]
      | flatMap![#A #B (cdr xs) f (rchan t)]
      | h?hs:(List B) = t?ts:(List B) =     {- receive both before appending -}
          append![#B hs ts (rchan a)]
      | a?res:(List B) = q!res ) )

{- mergePairs: merge two key-sorted lists of [Int V] using cmp, send result on q -}
def mergePairs [#V xs:(List [Int V]) ys:(List [Int V]) cmp:/[Int Int /Bool] q:/(List [Int V])] =
  if (null xs) then q!ys
  else if (null ys) then q!xs
  else
    ( val [kx vx] = (car xs)
      val [ky vy] = (car ys)
      new le:^Bool
      ( cmp![kx ky (rchan le)]
      | le?isLE:Bool =
          if isLE then
            ( new rest:^(List [Int V])
              ( mergePairs![#V (cdr xs) ys cmp (rchan rest)]
              | rest?rs:(List [Int V]) = q!(cons [kx vx] rs) ) )
          else
            ( new rest:^(List [Int V])
              ( mergePairs![#V xs (cdr ys) cmp (rchan rest)]
              | rest?rs:(List [Int V]) = q!(cons [ky vy] rs) ) ) ) )

{- print one tuple [Int Int] as (k:v) followed by a space -}
def printPairKV p:[Int Int] =
  ( val [k v] = p
    ( print!"("
    | printi!k
    | print!":"
    | printi!v
    | print!") "
    )
  )
  
{- print a list of [Int Int] -}
def printPairsKV xs:(List [Int Int]) =
  if (null xs) then
    print!"\n"
  else
    ( printPairKV!(car xs) 
      | printPairsKV!(cdr xs) )
    
{- dup: make a 2-element list [x, x] -}
def dup [x:Int q:/(List Int)] =
  q!(cons x (cons x nil))
  
{- inc: x ↦ x + 1, returning via q -}
def increment [x:Int q:/Int] =
  ( new s:^Int
    ( +![x 1 (rchan s)]
    | s?r:Int = q!r ))

{- compareInt: send (x <= y) on q -}
def compareInt [x:Int y:Int q:/Bool] =
  ( new b:^Bool
    ( <=![x y (rchan b)]
    | b?res = q!res ) )
    
val s1 = (cons [1 10] (cons [3 30] (cons [5 50] nil)))   {- sorted by key -}
val s2 = (cons [2 20] (cons [4 40] nil))                 {- sorted by key -}

new out:^(List [Int Int])
run (
  mergePairs![#Int s1 s2 compareInt (rchan out)]
| out?m:(List [Int Int]) = ( print!"merged: " | printPairsKV!m )
)
